- [1.单库单表](#1单库单表)
- [2.读写分离](#2读写分离)
- [3.垂直分库](#3垂直分库)
- [4.垂直分表](#4垂直分表)
- [5.水平分库分表](#5水平分库分表)
  - [水平分表](#水平分表)
  - [水平分库](#水平分库)
  - [水平分库分表带来的问题](#水平分库分表带来的问题)

## 1.单库单表

刚开始的时候，应用的数据比较少，业务也不会特别复杂，所以应用只有一个数据库，数据库中的每一张表都是完整的数据，这也是数据库的最初形态。

## 2.读写分离

随着业务发展，数据量和访问量都不断增长，但大多数业务都是读多写少。比如新闻网站的新闻、购物网站的商品，运营人员在后台编辑好后，所有的互联网用户都可能会去读取这些数据，因此数据库面临的读压力远大于写压力。这个时候在原来数据库(Master)基础上增加一个备用数据库(Slave)，备库和主库存储相同的数据，但只提供读服务，不提供写服务。写操作以及事务中的读操作走主库，其他读操作走备库，这样就实现了读写分离。在实现读写分离的基础上也能避免单机故障，导致无法对外提供服务。主数据库宕机，可以自动切换到备库，以实现系统容灾。

读写分离带来的问题：

* 数据的复制：新写入的数据只会在主库中，备库需要将数据的新增和修改从主库中复制过来。这个一般依靠数据库提供的复制功能实现，比如mysql基于binlog实现的的replication。
* 数据源的选择：读写分离后，我们都知道写要找主库，读要找备库，但是程序不知道。所以程序中应该根据SQL判断出是读操作还是写操作，进而选择要访问的数据库。这就涉及到SQL语法树的解析了，比如Druid连接池就提供了SQL Parser模块。

## 3.垂直分库

数据量和访问量仍在持续上升，主备库的压力都在上升。这时可以根据业务特点考虑将数据库进行功能性拆分，也就是把数据库中不同业务单元的数据表划分到不同的数据库中。

比如新闻网站中，注册用户的信息与新闻数据是没有多大关系的，数据库访问压力大时可以尝试把用户注册信息的表放在一个数据库，新闻相关的表放在另一个数据库中，这样减小了数据库的访问压力，同时便于对每个单独的业务按需进行水平扩展。这就与微服务的思想逐渐靠近，但具体业务拆分如何拆分，怎么控制拆分粒度，这需要根据业务进行仔细考量了。

垂直分库会带来以下几个问题：

* 事务的ACID将被打破：数据被分到不同的数据库，原来的事务操作将会受很大影响。比如说注册用户时需要在一个事务中往用户表和用户信息表插入一条数据，单机数据库可以利用本地事务很好地完成这件事儿，但是多机就会变得比较麻烦。这个问题就涉及到分布式事务，分布式事务的解决方案有很多，比如使用强一致性的分布式事务框架Seata，或者使用RocketMQ等消息队列实现最终一致性。
* Join联表操作困难：这个也毋庸置疑了，解决方案一般是将联表查询改成多个单次查询，在代码层进行关联。
* 外键约束受影响：因为外键约束和唯一性约束一样本质还是依靠索引实现的，所以分库后外键约束也会收到影响。但外键约束本就不太推荐使用，一般都是在代码层进行约束，这个问题倒也不会有很大影响。


## 4.垂直分表

除了垂直分库还有垂直分表的方式：主要以字段为依据，按照字段的活跃度，将表中的字段拆分到不同的表中。将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样主表的单行数据所需的存储空间变小，更多的热点数据就能被缓存下来，进而减少了随机磁盘I/O。拆了之后，要想获得全部数据就需要关联两个表来取数据。

比如用户表数据，用户的用户名、密码、年龄、性别、手机号等字段会被经常查询，而用户的家庭住址、个人介绍等字段又长而且不常访问，所以将这些字段拆分出来单独存一张表，可以让数据库的缓存更高效。

## 5.水平分库分表

### 水平分表
以某个字段为分区键，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。

其实MySQL的分区表能提供类似的功能。区别在于MySQL底层会自动分成多个文件存储，而手动分表需要在代码层改写SQL，根据分表字段映射到真正的表名。显然后者成本有点高。

分表能够解决单表数据量过大带来的查询效率下降的问题，但是却无法给数据库的并发处理能力带来质的提升。所以这个适合数据量上来但是并发访问量没上来的情况。

### 水平分库
这种方式明显更容易扩展, 库多了，io和cpu的压力自然可以成倍缓解。

### 水平分库分表带来的问题
* 自增主键会有影响：分表中如果使用的是自增主键的话，那么就不能产生唯一的ID了，因为逻辑上来说多个分表其实都属于一张表，数据库的自增主键无法标识每一条数据。一般采用分布式的id生成策略解决这个问题。
* 有些单表查询会变成多表：比如说count操作，原来是一张表的问题，现在要从多张分表中共同查询才能得到结果。
* 排序和分页影响较大：比如order by id limit 10, 按照10个一页取出第一页，原来只需要一张表执行直接返回给用户，现在有5个分库要从5张分表分别拿出10条数据然后排序，返回50条数据中最前面的10条。当翻到第二页的时候，需要每张表拿出20条数据然后排序，返回100条数据中的第二个11～20条。很明显这个操作非常损耗性能。


